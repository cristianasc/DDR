% average delay for menor ou igual, e neste caso se for igual entao o max
% delay tem de ser tamb√©m menor
Counter = 0;
GlobalBest1 = Inf;
GlobalBest2 = Inf;
while Counter < 20
    [CurrentSolution, lambda] = GreedyRandomized(); 
    [CurrentObjective1, CurrentObjective2] = Evaluate(CurrentSolution, lambda);  %AverageDelay
    repeat= true;
    while repeat
         NeighbourBest1 = Inf;
         NeighbourBest2 = Inf;
         for i=1:size(CurrentSolution,1)
             NeighbourSolution= BuildNeighbour(CurrentSolution,lambda, i); 
             [NeighbourObjective1, NeighbourObjective2] = Evaluate(NeighbourSolution, lambda);
             actuak
             if NeighbourObjective1 < NeighbourBest1
                 NeighbourBest1 = NeighbourObjective1;
                 NeighbourBest2 = NeighbourObjective2;
                 NeighbourBestSolution = NeighbourSolution;  
             elseif NeighbourObjective1 == NeighbourBest1
                 if NeighbourObjective2 < NeighbourBest2
                    NeighbourBest1 = NeighbourObjective1;
                    NeighbourBest2 = NeighbourObjective2;
                    NeighbourBestSolution= NeighbourSolution;
                 end
             end
         end
         if NeighbourBest1 < CurrentObjective1 || (NeighbourBest1 == CurrentObjective1 && NeighbourObjective2 < CurrentObjective2)
             CurrentObjective1 = NeighbourBest1;
             CurrentObjective2 = NeighbourBest2;
             CurrentSolution = NeighbourBestSolution;
         else
             repeat= false;
         end
     end
     if CurrentObjective1 < GlobalBest1 || (CurrentObjective1 == GlobalBest1 &&   CurrentObjective2 < GlobalBest2) 
         GlobalBestSolution = CurrentSolution;
         GlobalBest1 = CurrentObjective1;
         GlobalBest2 = CurrentObjective2;
         Counter = 0;
     else
         Counter = Counter + 1;
     end
end

Matrizes;
miu= R*1e9/(8*1000);
NumberLinks= sum(sum(R>0));
T(:,3:4)= T(:,3:4)*1e6/(8*1000); % transforma em pacotes por segundo
gama= sum(sum(T(:,3:4)));
d= L*1e3/2e8;

Load= lambda./miu;
Load(isnan(Load))= 0;
MaximumLoad = max(max(Load))
AverageLoad = sum(sum(Load))/NumberLinks

Load= lambda./miu;
Load(isnan(Load))= 0;
MaximumLoad = max(max(Load)); % descomentar para ver o resultado
AverageLoad = sum(sum(Load))/NumberLinks; % descomentar para ver o resultado

% Kleinrock aproximation => network average delay
RTDelay = (lambda./(miu-lambda)+lambda.*d);
RTDelay(isnan(RTDelay)) = 0;
RTDelay = sum(sum(RTDelay))/gama;
RTDelay = RTDelay*2 %ida e volta => descomentar para ver o resultado